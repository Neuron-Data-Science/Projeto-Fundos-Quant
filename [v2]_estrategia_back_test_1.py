# -*- coding: utf-8 -*-
"""[V2] ESTRATEGIA_BACK_TEST_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-gVN4xhiylMxWb2my5yY-6DxT37OCxrS

#### Importando Bibliotecas Necessárias
"""

# yahoo finance para pegar dados históricos
import yfinance as yf

# statistics para calcular a volatilidade/risco
from statistics import pstdev

# numpy para fórmulas matemáticas 
import numpy as np

# pandas para manipular dataframes/datasets/conjunto de dados
import pandas as pd

"""#### Criando a função para pegar dados dos preços históricos"""

# Retorna uma "planilha de excel", mais conhecido como dataframe com os seguintes campos ['Open', 'High', 'Low', 'Close', 'Volume', 'Dividends', 'Stock Splits']

def catch_data(code, start_date, end_date):
    # get data on this ticker
    tickerData = yf.Ticker(code)

    # get the historical prices for this ticker
    tickerDf = tickerData.history(period='1d', start=start_date, end=end_date)
   
    return tickerDf

"""#### Criando a função para extrair as médias móveis"""

# Deve receber um dataframe (df) com apenas uma coluna com o preço de fechamento. Retornará um dataset com mais uma coluna nomeada como SMAx onde x = número de dias da média móvel
def get_moving_average(df, days):
    # str(days) transforma em string o objeto "days" dado para a função, assim vou ter no nome da coluna o número de dias daquela média móvel. ex: SMA9, SMA40
    # df.iloc[:, 1]  seleciona todas as observações da coluna 1 (deve ser a coluna de preços de fechamento, lembre-se disso ao colocar o objeto df na função)
    # rolling(window=days).mean() faz a mágica acontecer, ele faz a média móvel de toda a série temporal.
    
    df['SMA' + str(days)] = df.iloc[:, 1].rolling(window=days).mean()

    return df

"""#### Criando a função para calcular retorno a partir das médias móveis"""

# Salva 1 em "buy_or_sell" se é para comprar e -1, caso contrário. Calcula o retorno e salva em "ret" para cada linha a depender da posição.

def get_return(df):
    buy_or_sell = []
    
    # Passando em cada linha do dataframe e coletando a posição 1 ou -1.
    for i in range(df.shape[0]):
        sma9 = df.SMA9[i]
        sma40 = df.SMA40[i]

        if sma9 > sma40:
            buy_or_sell.append(1)
        else:
            buy_or_sell.append(-1)

    # Salvando o valor do buy_or_sell na coluna chamada "strategy"
    df['strategy'] = buy_or_sell

    # Calcula o retorno normal se o valor da coluna "strategy" for igual a 1 e em caso contrário fazer a mesma coisa E multiplica por -1.
    ret = []

    # Passando em cada linha do dataframe e calculando o retorno.
    for i in range(df.shape[0]):
        if i == df.shape[0]-1:
            # Fiz esse if para não dar erro no i-1 (já que i-1, quando i=0 ficaria fora do range)
            ret.append(np.NaN)
        else:
            strategy = df['strategy'][i]
            priced = df.Close[i]
            priced1 = df.Close[i+1]
            if strategy == 1:
                ret.append(np.log(priced1/priced))
            else:
                ret.append(np.log(priced1/priced) * -1)
    
    # Salvando o valor do ret na coluna chamada "return"
    df['return'] = ret

    # Retornando o dataset completo com todas as informações novas
    return df

"""#### Chamando/rodando todas as funções para o ano de 2020."""

# Fazendo o upload dos dados (PETOBRÁS, 2020)
# Não se esqueça de colocar o código válido (ide https://finance.yahoo.com/ e confira)
# Coloquei ["Close"] no fim para pegar apenas o preço de fechamento
dataset_root = catch_data("PETR3.SA", '2020-01-02', '2020-12-31')['Close']

# resenting the index (necessário para rodar as funções) (resumidamente, só coloca as datas como uma coluna, antes elas eram índices, o que limita seu uso)
dataset_root = dataset_root.reset_index()

# Obtem média móvel 9
dataset_with_smm9 = get_moving_average(dataset_root, 9)

# Obtem média móvel 40
dataset_with_smm40 = get_moving_average(dataset_with_smm9, 40)

# Obtem retorno
dataset_with_return = get_return(dataset_with_smm40)

# Apaga os valores com NaN (sem valores) para não dar problema nas fórmulas
dataset_with_return.dropna(inplace=True)

# Calculando o desvio-padrão e entregando a volatilidade APENAS na coluna "Close"
volatility = pstdev(dataset_with_return['Close'])

# Definindo a taxa livre de risco
free_rate = pd.read_csv('free_rate.csv', sep=';').set_index('ANO')
free_rate_value = free_rate['t_bond_acumulada'][2020]

# função shape retorna o formato do dataset, pego apenas a posição 0 que me entrega a quantidade de linhas, que é o mesmo que a última posição do dataset
ultimo_valor =  dataset_with_return['Close'][dataset_with_return.shape[0]]

# pego a posição 39 porque é a partir dessa posição que tem valores já que eliminamos as primeiras 40 observações devido as médias móveis
primeiro_valor = dataset_with_return['Close'][39]

# Retorno buy and hold (Estratégia de comparação) (utilizando a função numpy definida como "np")
ret_buy_hold = np.log(ultimo_valor / primeiro_valor)
sharpe_index_buy_hold = (ret_buy_hold - free_rate_value)/volatility

# Retorno da nossa estratégia
ret_strategy = np.sum(dataset_with_return['return'])
sharpe_index_strategy = (ret_strategy - free_rate_value)/volatility

print("RETORNO DA ESTRATÉGICA: ", ret_strategy, '\nVOLATILIDADE: ', volatility, '\nT-Bond: ', free_rate_value)
print('\n')
print('Índice Sharpe da Estratégia: ', round(sharpe_index_strategy*100, 2), '%', '\nÍndice Sharpe da Buy and Hold: ', round(sharpe_index_buy_hold*100, 2), '%')

"""### Calculando o nível de acerto

"""

acerto = 0
erro = 0 
for i in range(39, dataset_with_return.shape[0]):
  if i == 39:
    x = dataset_with_return['Close'][39]
    s = dataset_with_return['strategy'][39]

  if s != dataset_with_return['strategy'][i] and i != 39:
    y = dataset_with_return['Close'][i]
    if s == -1:
      if y-x > 0:
        erro =  erro + 1
      else:
        acerto = acerto + 1
    if s == 1:
      if y-x > 0:
        acerto = acerto + 1
      else:
        erro =  erro + 1

    s = dataset_with_return['strategy'][i]
    x=y

acerto/(acerto+erro)

"""### Vamos generalizar para vários anos."""

periods = [['2000-01-03', '2000-11-29', 2000], ['2001-01-02', '2001-12-31', 2001], ['2002-01-02', '2002-12-31', 2002], ['2003-01-02', '2003-12-31', 2003],
           ['2004-01-02', '2004-12-31', 2004], ['2005-01-03', '2005-12-30', 2005], ['2006-01-02', '2006-12-29', 2006], ['2007-01-02', '2007-12-31', 2007],
           ['2008-01-02', '2008-12-31', 2008], ['2009-01-02', '2009-12-31', 2009], ['2010-01-04', '2010-12-31', 2010], ['2011-01-03', '2011-12-30', 2011],
           ['2012-01-02', '2012-12-31', 2012], ['2013-01-02', '2013-12-31', 2013], ['2014-01-02', '2014-12-31', 2014], ['2015-01-02', '2015-12-31', 2015],
           ['2016-01-04', '2016-12-30', 2016], ['2017-01-02', '2017-12-29', 2017], ['2018-01-01', '2018-12-31', 2018], ['2019-01-02', '2019-12-31', 2019],
           ['2020-01-02', '2020-12-31', 2020], ['2000-01-03', '2020-12-31', 0]]

def sharpe_index_comparison(free_rate_value, code, start_date, end_date, day1, day2):
  dataset_root = catch_data(code, start_date, end_date)['Close']

  # resenting the index (necessário para rodar as funções) (resumidamente, só coloca as datas como uma coluna, antes elas eram índices, o que limita seu uso)
  dataset_root = dataset_root.reset_index()

  # Obtem média móvel 9
  dataset_with_smm9 = get_moving_average(dataset_root, day1)

  # Obtem média móvel 40
  dataset_with_smm40 = get_moving_average(dataset_with_smm9, day2)

  # Obtem retorno
  dataset_with_return = get_return(dataset_with_smm40)

  # Apaga os valores com NaN (sem valores) para não dar problema nas fórmulas
  dataset_with_return.dropna(inplace=True)

  # Calculando o desvio-padrão e entregando a volatilidade APENAS na coluna "Close"
  volatility = pstdev(dataset_with_return['Close'])

  # função shape retorna o formato do dataset, pego apenas a posição 0 que me entrega a quantidade de linhas, que é o mesmo que a última posição do dataset
  ultimo_valor =  dataset_with_return['Close'][dataset_with_return.shape[0]]

  # pego a posição 39 porque é a partir dessa posição que tem valores já que eliminamos as primeiras 40 observações devido as médias móveis
  primeiro_valor = dataset_with_return['Close'][39]

  # Retorno buy and hold (Estratégia de comparação) (utilizando a função numpy definida como "np")
  ret_buy_hold = np.log(ultimo_valor / primeiro_valor)
  sharpe_index_buy_hold = (ret_buy_hold - free_rate_value)/volatility

  # Retorno da nossa estratégia
  ret_strategy = np.sum(dataset_with_return['return'])
  sharpe_index_strategy = (ret_strategy - free_rate_value)/volatility
  print(f'SHARPE INDEX BUY AND HOLD: {sharpe_index_buy_hold}')
  print(f'SHARPE INDEX STRATEGY:  {sharpe_index_strategy}')

  acerto = 0
  erro = 0 
  for i in range(39, dataset_with_return.shape[0]):
    if i == 39:
      x = dataset_with_return['Close'][39]
      s = dataset_with_return['strategy'][39]

    if s != dataset_with_return['strategy'][i] and i != 39:
      y = dataset_with_return['Close'][i]
      if s == -1:
        if y-x > 0:
          erro =  erro + 1
        else:
          acerto = acerto + 1
      if s == 1:
        if y-x > 0:
          acerto = acerto + 1
        else:
          erro =  erro + 1

      s = dataset_with_return['strategy'][i]
      x=y

  nivel_acerto = acerto/(acerto+erro)

  return sharpe_index_strategy, sharpe_index_buy_hold, ret_strategy, volatility, free_rate_value, nivel_acerto

# Dicionário para coletar dados dos resultados
dicionario = {'Empresa': [], 'Ano': [], 'Sharpe_Ratio': [], 'Sharpe_Ratio_Buy_and_Hold': [], 'Retorno': [], 'Volatilidade': [], 'Taxa_Livre_de_Risco': [], 'Nivel_de_Acerto': []}

print('-------- PETROBRÁS --------')

# Passando em cada objeto da lista "periods"
# "date" será esse objeto. ex: na primeira rodada date = ['2000-01-03', '2000-11-29', 2000], na segunda, date = ['2001-01-02', '2001-12-31', 2001], e assim por diante.
for date in periods:
    # pego a posição 2 do "date", ou seja, pego o último argumentando entregando o ano em questão (2000, 2001, etc)
    free_rate_position = date[2]

    # Definindo a taxa livre de risco a partir do excel externo
    free_rate = pd.read_csv('free_rate.csv', sep=';').set_index('ANO')
    free_rate_value = free_rate['t_bond_acumulada'][free_rate_position]

    # coleto a data de início (primeira posição, no caso, "0") e fim (segunda posição, no caso, "1") 
    start_date = date[0]
    end_date = date[1]

    print('-------- INTERVALO DE ', start_date, ' ATÉ ', end_date, '--------')
    
    sharpe_ratio, sharpe_ratio_buy_hold, retorno, volatilidade, taxa_livre_riscos, nivel_de_acerto = sharpe_index_comparison(free_rate_value, 'PETR4.SA', start_date, end_date, 9, 40)
  
    dicionario['Empresa'].append('Petrobrás')    
    dicionario['Ano'].append(free_rate_position)
    dicionario['Sharpe_Ratio'].append(sharpe_ratio*100)
    dicionario['Sharpe_Ratio_Buy_and_Hold'].append(sharpe_ratio_buy_hold*100)
    dicionario['Retorno'].append(retorno*100)
    dicionario['Volatilidade'].append(volatilidade*100)
    dicionario['Taxa_Livre_de_Risco'].append(taxa_livre_riscos*100)
    dicionario['Nivel_de_Acerto'].append(nivel_de_acerto*100)

print('-------- VALE --------')

# Passando em cada objeto da lista "periods"
# "date" será esse objeto. ex: na primeira rodada date = ['2000-01-03', '2000-11-29', 2000], na segunda, date = ['2001-01-02', '2001-12-31', 2001], e assim por diante.
for date in periods:
    # pego a posição 2 do "date", ou seja, pego o último argumentando entregando o ano em questão (2000, 2001, etc)
    free_rate_position = date[2]

    # Definindo a taxa livre de risco a partir do excel externo
    free_rate = pd.read_csv('free_rate.csv', sep=';').set_index('ANO')
    free_rate_value = free_rate['t_bond_acumulada'][free_rate_position]

    # coleto a data de início (primeira posição, no caso, "0") e fim (segunda posição, no caso, "1") 
    start_date = date[0]
    end_date = date[1]

    print('-------- INTERVALO DE ', start_date, ' ATÉ ', end_date, '--------')
    
    sharpe_ratio, sharpe_ratio_buy_hold, retorno, volatilidade, taxa_livre_riscos, nivel_de_acerto = sharpe_index_comparison(free_rate_value, 'VALE3.SA', start_date, end_date, 9, 40)

    dicionario['Empresa'].append('Vale')    
    dicionario['Ano'].append(free_rate_position)
    dicionario['Sharpe_Ratio'].append(sharpe_ratio*100)
    dicionario['Sharpe_Ratio_Buy_and_Hold'].append(sharpe_ratio_buy_hold*100)
    dicionario['Retorno'].append(retorno*100)
    dicionario['Volatilidade'].append(volatilidade*100)
    dicionario['Taxa_Livre_de_Risco'].append(taxa_livre_riscos*100)
    dicionario['Nivel_de_Acerto'].append(nivel_de_acerto*100)

"""### Transformando em um dataframe"""

import pandas as pd

df = pd.DataFrame.from_dict(dicionario)
df.to_csv('Estrategia_Back_Test.csv')
